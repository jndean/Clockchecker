<!-- 
 As may quickly become apparent, this was vibe-coded as a single file GUI
 front-end in Gemini+Canvas, then the Clockchecker / Pyscript backend was 
 inserted aferwards.
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <script src="./mini-coi.js"></script> <!-- Hack to allow cross-origin :) -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.3">
    <title>Clockchecker Interactive</title>
    <script src="./tailwindcss.js"></script>
    <script src="./mini-lz-string.js"></script>

    <!-- CodeMirror -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/mode/overlay.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/comment/comment.min.js"></script>
    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.5.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.5.1/core.js"></script>

    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
</head>

<body>

    <script type="py" worker src="main" config="pyscript-config.toml"></script>

    <div class="main-app-container">
        <div id="puzzleSamplesTrayWrapper" class="samples-tray-wrapper">
            <div id="toggleLongSamplesTrayButton" class="toggle-samples-tray-button">Puzzles</div>
            <div id="puzzleSamplesTray" class="samples-tray"></div>
        </div>

        <div id="characterSamplesTrayWrapper" class="samples-tray-wrapper">
            <div id="toggleShortSamplesTrayButton" class="toggle-samples-tray-button">Characters</div>
            <div id="characterSamplesTray" class="samples-tray"></div>
        </div>

        <div class="main-content-wrapper">
            <div class="app-header">
                <div class="app-title-container">
                    <h1 class="app-title">Clockchecker Interactive</h1>
                    <button id="infoButton" title="About this App">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="feather feather-info">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                    </button>
                </div>
                <button id="helpButton" title="How to use this app">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="feather feather-help-circle">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>
            </div>
            <div class="main-content">
                <div class="panels-container">
                    <div id="inputPanel" class="panel input-panel">
                        <!-- Tab Bar -->
                        <div class="input-tab-bar">
                            <button id="textTabBtn" class="input-tab active" data-tab="text">Text</button>
                            <button id="builderTabBtn" class="input-tab" data-tab="builder">Builder</button>
                        </div>

                        <!-- Text Input Panel (existing) -->
                        <div id="textInputContainer" class="input-tab-content active">
                            <div class="share-button-container">
                                <div id="shareSuccessMsg" class="share-success-msg" style="display: none;"></div>
                                <button id="shareButton" class="history-button"
                                    title="Share a link to this puzzle&#10;(including current output)"><img
                                        class="link-image" src="link.png"></button>
                            </div>
                            <div class="history-buttons-container">
                                <button id="undoInputButton" class="history-button" title="Undo (Ctrl+Z)">‚Üê</button>
                                <button id="redoInputButton" class="history-button" title="Redo (Ctrl+Y)">‚Üí</button>
                            </div>
                            <textarea id="inputText" placeholder="Enter text here..."></textarea>
                        </div>

                        <!-- GUI Builder Panel (new) -->
                        <div id="builderInputContainer" class="input-tab-content">
                            <!-- Setup Section -->
                            <div id="builderSetup" class="builder-section">
                                <div class="builder-setup-header">
                                    <label for="playerNamesInput">Player Names (comma-separated):</label>
                                </div>
                                <div class="builder-setup-row">
                                    <input type="text" id="playerNamesInput"
                                        placeholder="You, Tim, Sarah, Oscar, Anna..." class="builder-text-input">
                                    <button id="startBuilderBtn" class="builder-start-btn">Start</button>
                                </div>
                            </div>

                            <!-- Players Container -->
                            <div id="builderPlayers" class="builder-players-container"></div>

                            <!-- Global Settings Section -->
                            <div id="builderGlobals" class="builder-section builder-globals" style="display: none;">
                                <h4 class="builder-section-title">
                                    <span class="collapse-icon">‚ñº</span> Puzzle Settings
                                </h4>
                                <div class="builder-section-content">
                                    <!-- Hidden Characters -->
                                    <div class="builder-field-inline">
                                        <label>Hidden Characters:</label>
                                        <div id="hiddenCharsContainer" class="builder-multi-select"></div>
                                        <button class="builder-add-btn builder-add-hidden-char">+ Add</button>
                                    </div>

                                    <!-- Hidden Self -->
                                    <div class="builder-field-inline">
                                        <label>Hidden Self:</label>
                                        <div id="hiddenSelfContainer" class="builder-multi-select"></div>
                                        <button class="builder-add-btn builder-add-hidden-self">+ Add</button>
                                    </div>

                                    <!-- Day Events -->
                                    <div class="builder-field">
                                        <label>Day Events:</label>
                                        <div id="dayEventsContainer" class="builder-events-container"></div>
                                        <button class="builder-add-btn builder-add-day-event">+ Add Day Event</button>
                                    </div>

                                    <!-- Night Deaths -->
                                    <div class="builder-field">
                                        <label>Night Deaths:</label>
                                        <div id="nightDeathsContainer" class="builder-events-container"></div>
                                        <button class="builder-add-btn builder-add-night-death">+ Add</button>
                                    </div>

                                    <!-- Options -->
                                    <div class="builder-field builder-checkbox-field">
                                        <input type="checkbox" id="allowDuplicateTokens">
                                        <label for="allowDuplicateTokens">Allow duplicate tokens in bag</label>
                                    </div>
                                </div>
                            </div>

                            <!-- Generate Code Button -->
                            <div id="builderActions" class="builder-actions" style="display: none;">
                                <button id="generateCodeBtn" class="builder-generate-btn">Generate Code</button>
                            </div>
                        </div>
                    </div>

                    <div id="vResizer" class="resizer v-resizer"></div>

                    <div class="right-column-container">
                        <div id="renderPanel" class="panel render-panel">
                            <!-- Scrollable visualization container -->
                            <div id="renderDisplay" class="render-display">
                                <div class="render-loading">
                                    <div class="spinner"></div>
                                    <span>Initialising puzzle renderer</span>
                                </div>
                            </div>

                            <!-- Fixed error toast -->
                            <div id="renderErrorToast" class="error-toast" style="display: none;">
                                <span id="renderErrorText"></span>
                                <button class="close-toast-btn" id="closeToastBtn">&times;</button>
                            </div>
                        </div>

                        <div id="hResizer" class="resizer h-resizer"></div>

                        <div id="outputPanel" class="panel output-panel">
                            <div id="outputText" class="output-content-area"
                                placeholder="Solutions will appear here..."></div>
                            <div id="outputInfoBar">Solutions: - | Time taken: --</div>
                        </div>
                    </div>
                </div>

                <div class="controls-container">
                    <button id="pythonLoadingMessage" class="python-loading-message">
                        <span>Initialising Python, please wait</span>
                        &nbsp;&nbsp;
                        <svg class="animate-spin h-5 w-5 text-white" style="display: inline-block;"
                            xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4">
                            </circle>
                            <path class="opacity-75" fill="currentColor"
                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                            </path>
                        </svg>
                    </button>
                    <div id="takingTooLongPopup">Taking too long?</div>
                    <button id="applyButton" class="apply-button" style="display: none;">
                        <span>Solve (Ctrl + Enter)</span>
                    </button>
                    <button id="stopButton" class="stop-button" style="display: none;">
                        <svg id="stopButtonSpinner" class="animate-spin h-5 w-5 text-white" style="display: none;"
                            xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4">
                            </circle>
                            <path class="opacity-75" fill="currentColor"
                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                            </path>
                        </svg>
                        <span id="stopButtonText">Stop</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3>What is this?</h3>
                <button id="closeInfoModal" class="modal-button close-dialog">&times;</button>
            </div>
            <p>
                <strong><span style="color: #7fa5f3">Clockchecker</span></strong> is a solver of <span
                    style="color: plum">Blood on the Clocktower's</span> puzzles,
                specifically the kind posted by reddit user u/Not_Quite_Vertical.
                An archive of their puzzles is <a
                    href="https://notquitetangible.blogspot.com/2024/11/clocktower-puzzle-archive.html"
                    target="_blank"><u>here</u></a>.
                The project page for clockchecker is <a href="https://github.com/jndean/clockchecker"
                    target="_blank"><u>here</u></a>.
                <br><br>
                <strong><span style="color: #7fa5f3">Clockchecker Interactive</span></strong> (i.e., this webpage) is a
                statically-hosted web GUI for <span style="color: #7fa5f3">clockchecker</span>.
                It was vibe-coded using Gemini+Canvas, because I am not a front-end guy. The <span
                    style="color: #7fa5f3">clockchecker</span> solver runs using PyScript, which is the full(ish)
                CPython interpreter compiled into WASM bytecode that runs in your browser. It uses a single thread, so
                it is not particularly fast (I've found it to be around <b>20x slower</b> than running natively on a
                16-core CPU).
                But it does work, which I think is pretty neat. ‚ú®
            </p>
        </div>
    </div>

    <div id="longTransformInfoDialogOverlay" class="modal-overlay">
        <div id="longTransformInfoDialogContent" class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3>Why is it slow?</h3>
                <button id="closeLongTransformInfoDialog" class="modal-button close-dialog">&times;</button>
            </div>
            <p>
                <span style="color: #7fa5f3">Clockchecker</span> is a hobby project. To try to keep it fun, it is
                written in Python, and the design decisions lean
                towards conceptual simplicity rather than efficiency. This helps keep the sprawling complexity of
                <span style="color: plum">Blood on the Clocktower's</span> character
                interactions managable, but it does mean it's not as fast as it could be. Additionally,
                <span style="color: #7fa5f3">Clockchecker Interactive</span>
                (this web front-end) runs the solver in a single thread, in a Python interpreter, in a WASM runtime, in
                your browser...
            </p>
            <p>
                If you would like to run the solver faster (e.g. <span style="color: #059669; font-weight: bold;">~20x
                    faster</span> if you have a 16-core CPU), you can
                download the <span style="color: #7fa5f3">clockchecker</span> source from <a
                    href="https://github.com/jndean/clockchecker" target="_blank"><u>github</u></a>
                and run it natively, no installation required.
            </p>
        </div>
    </div>


    <div id="messageBoxOverlay" class="message-box-overlay">
        <div class="message-box">
            <p id="messageBoxText"></p>
            <button id="messageBoxOkButton">OK</button>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <div class="flex justify-between items-center mb-4">
                <h3>How to Use</h3>
                <button id="closeHelpModal" class="modal-button close-dialog">&times;</button>
            </div>
            <div class="modal-scroll-area" style="overflow-y: auto; padding-right: 0.5rem; max-height: 60vh;">
                <p>
                    <strong>Puzzle Input</strong><br>
                    The left panel is a python code editor. Write the puzzle specification here, this will be the input
                    to the solver. See the Puzzles tab for examples of previously written puzzles. See the Characters
                    tab
                    for example snippets describing each character. You can click a character snippet to insert it into
                    the
                    puzzle input at the current cursor location.
                </p>
                <p>
                    <strong>Puzzle Visualization</strong><br>
                    The top-right panel automatically renders a visual representation of the puzzle in the input. This
                    is
                    an automatically generated, best-efforts attempt, it may have poor layout or misrepresent some
                    details.
                    You can resize the panels to make the render easier to see.
                    (Note, the render is done by the same python thread that solves the puzzle, so the render will not
                    update
                    while the solver is running).
                </p>
                <p>
                    <strong>Solve</strong><br>
                    Click the <strong>Solve</strong> button to find possible solutions to the puzzle in the input.
                    Solutions will be displayed in the bottom right output panel. Click any solution to render it to the
                    visualisation panel.
                </p>

                <p>
                    <strong>Sharing</strong><br>
                    Click the üîó icon in the top right ofthe input panel to copy a shareable link that includes your
                    current puzzle and solutions.
                </p>
            </div>
        </div>
    </div>

    <!-- Incomplete Fields Warning Modal -->
    <div id="incompleteFieldsModalOverlay" class="modal-overlay">
        <div id="incompleteFieldsModalContent" class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3>Incomplete Fields</h3>
                <button id="closeIncompleteFieldsModal" class="modal-button close-dialog">&times;</button>
            </div>
            <p id="incompleteFieldsMessage"></p>
            <div style="display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: flex-end;">
                <button id="incompleteFieldsCancelBtn" class="modal-button"
                    style="background-color: #6b7280; color: white;">Cancel</button>
                <button id="incompleteFieldsGenerateBtn" class="modal-button"
                    style="background-color: #f59e0b; color: white;">Generate Anyway</button>
            </div>
        </div>
    </div>

    <script src="puzzles.js"></script>
    <script src="characters.js"></script>
    <script src="gui-schema.js"></script>

    <script>
        const inputTextElement = document.getElementById('inputText');
        const outputText = document.getElementById('outputText');
        const outputInfoBar = document.getElementById('outputInfoBar');
        const applyButton = document.getElementById('applyButton');
        const stopButton = document.getElementById('stopButton');
        const stopButtonText = document.getElementById('stopButtonText');
        const stopButtonSpinner = document.getElementById('stopButtonSpinner');
        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxOkButton = document.getElementById('messageBoxOkButton');
        const undoInputButton = document.getElementById('undoInputButton');
        const redoInputButton = document.getElementById('redoInputButton');
        const shareButton = document.getElementById('shareButton');
        const shareSuccessMsg = document.getElementById('shareSuccessMsg');
        const renderPanel = document.getElementById('renderPanel');
        const renderErrorToast = document.getElementById('renderErrorToast');
        const renderErrorText = document.getElementById('renderErrorText');

        const puzzleSamplesTrayWrapper = document.getElementById('puzzleSamplesTrayWrapper');
        const puzzleSamplesTray = document.getElementById('puzzleSamplesTray');
        const toggleLongSamplesTrayButton = document.getElementById('toggleLongSamplesTrayButton');

        const characterSamplesTrayWrapper = document.getElementById('characterSamplesTrayWrapper');
        const characterSamplesTray = document.getElementById('characterSamplesTray');
        const toggleShortSamplesTrayButton = document.getElementById('toggleShortSamplesTrayButton');

        const infoButton = document.getElementById('infoButton');
        const infoModal = document.getElementById('infoModal');
        const closeInfoModalButton = document.getElementById('closeInfoModal');

        const takingTooLongPopup = document.getElementById('takingTooLongPopup');
        const longTransformInfoDialogOverlay = document.getElementById('longTransformInfoDialogOverlay');
        const closeLongTransformInfoDialogButton = document.getElementById('closeLongTransformInfoDialog');
        let takingTooLongTimerId = null;

        const helpButton = document.getElementById('helpButton');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalButton = document.getElementById('closeHelpModal');

        const currentTransform = 'reverseText';
        const SIMULATED_DELAY_MS_PER_CHUNK = 5;

        let inputHistory = [];
        let currentHistoryIndex = -1;
        const MAX_HISTORY_SIZE = 20;
        let debounceTimer = null;
        const DEBOUNCE_DELAY = 300;
        let codeMirrorEditor;


        const InfoTokens = [
            "IsCharacter",
            "IsEvil",
            "IsDroisoned",
            "IsAlive",
            "IsCategory",
            "IsInPlay",
            "CharAttrEq",
            "PlayerAttrEq",
            "ExactlyN",
            "SameCategory",
            "Dies",
            "ExecutionByST",
            "Execution",
            "DrunkBetweenTownsfolk",
            "LongestRowOfTownsfolk",
            "CharacterTypesAmongPlayers",
            "WidowPoisoned",
            "Doomsayer",
            "UneventfulNomination",
        ];

        const DataTokens = [
            "Minion",
            "Deamon",
            "Townsfolk",
            "Outsider",
        ];

        document.addEventListener("DOMContentLoaded", function () {
            try {
                const blueTokens = Townsfolk.concat(Outsiders);
                const purpleTokens = InfoTokens.concat(['Puzzle', 'Player']);

                CodeMirror.defineMode("python-custom-overlay", function (config, parserConfig) {
                    let pythonMode = CodeMirror.getMode(config, "python");
                    return CodeMirror.overlayMode(pythonMode, {
                        token: function (stream, state) {
                            if (stream.match("#", true, false)) {
                                while (stream.next() != null) { };
                                return null;
                            }
                            for (let token of blueTokens) {
                                if (stream.match(token, true, false)) {
                                    return "custom-blue-tokens";
                                }
                            }
                            for (let token of Evils) {
                                if (stream.match(token, true, false)) {
                                    return "custom-red-tokens";
                                }
                            }
                            for (let token of purpleTokens) {
                                if (stream.match(token, true, false)) {
                                    return "custom-purple-tokens";
                                }
                            }
                            for (let token of DataTokens) {
                                if (stream.match(token, true, false)) {
                                    return "custom-orange-tokens";
                                }
                            }
                            // Advance stream if no custom token is matched to avoid infinite loops
                            while (stream.next() != null) {
                                let matched = false;
                                if (stream.match("#", true, false)) { while (stream.next() != null) { }; return null; };
                                for (let token of blueTokens) if (stream.match(token, false, true)) matched = true;
                                for (let token of Evils) if (stream.match(token, false, true)) matched = true;
                                for (let token of purpleTokens) if (stream.match(token, false, true)) matched = true;
                                for (let token of DataTokens) if (stream.match(token, false, true)) matched = true;
                                if (matched) break; // Break to re-evaluate from the start of a potential match
                            }
                            return null; // Let base Python mode handle other tokens
                        }
                    });
                });


                codeMirrorEditor = CodeMirror.fromTextArea(inputTextElement, {
                    mode: "python-custom-overlay", // Use the new overlay mode
                    theme: "material-darker",
                    lineNumbers: true,
                    autoCloseBrackets: true,
                    matchBrackets: true,
                    indentUnit: 4,
                    smartIndent: true,
                    readOnly: false,
                    lineComment: true,
                });
                globalThis.codeMirrorEditor = codeMirrorEditor;

                codeMirrorEditor.on("change", (editor, changeObj) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        saveInputState(editor.getValue(), true);
                        update_render();
                    }, DEBOUNCE_DELAY);
                });
                update_render(); // Initial render

                // Set starting puzzle
                var url = new URL(window.location);
                let puzzle_payload = url.searchParams.get('puzzle');
                if (puzzle_payload === null) {
                    puzzleSamples["NotQuiteTangible"].forEach(puzzle => {
                        if (puzzle.name == 'NQT41') {
                            codeMirrorEditor.setValue(puzzle.value);
                        }
                    });
                } else {
                    codeMirrorEditor.setValue(LZString.decompressFromEncodedURIComponent(puzzle_payload));
                }
                saveInputState(codeMirrorEditor.getValue() || "");
                codeMirrorEditor.focus();
            } catch (e) {
                console.error("Error initializing CodeMirror:", e);
                showUserMessage("Error initializing code editor. Please try refreshing the page.");
            }
        });


        function saveInputState(newState, isUserInput = false) {
            if (!isUserInput) clearTimeout(debounceTimer);

            if (currentHistoryIndex >= 0 && inputHistory[currentHistoryIndex] !== undefined && newState === inputHistory[currentHistoryIndex]) {
                updateUndoRedoButtonStates();
                return;
            }

            if (currentHistoryIndex < inputHistory.length - 1) {
                inputHistory = inputHistory.slice(0, currentHistoryIndex + 1);
            }

            inputHistory.push(newState);

            if (inputHistory.length > MAX_HISTORY_SIZE) {
                inputHistory.shift();
            }
            currentHistoryIndex = inputHistory.length - 1;
            updateUndoRedoButtonStates();
        }

        function updateUndoRedoButtonStates() {
            // undoInputButton.disabled = currentHistoryIndex <= 0;
            // redoInputButton.disabled = currentHistoryIndex >= inputHistory.length - 1;
        }

        function make_puzzle_card(data) {
            const puzzleCard = document.createElement('div');
            const title = document.createElement('div');
            title.className = 'sample-title';
            title.textContent = 'üß© ' + data.name;
            puzzleCard.appendChild(title);
            claims = [];
            function colour_claim(claim) {
                let colour = '89DDFF';
                if (Outsiders.includes(claim)) colour = '7af';
                else if (Evils.includes(claim)) colour = 'f88';
                return `<span style="color: #${colour}">${claim}</span>`;
            }
            character_content = '<strong>Claims:</strong> ';
            character_content += data.claims.map(colour_claim).join(', ');
            character_content += '<br><strong>Hidden:</strong> ';
            character_content += data.hidden.map(colour_claim).join(', ');
            // data.claims.forEach(colour_claim);
            const characters = document.createElement('div');
            characters.innerHTML = character_content
            puzzleCard.appendChild(characters);

            puzzleCard.className = 'sample-item-card';
            puzzleCard.dataset.sampleValue = data.value;

            return puzzleCard;
        }


        function populateLongSamplesTray() {
            puzzleSamplesTray.innerHTML = '';
            const mainLabel = document.createElement('h3');
            mainLabel.textContent = 'Puzzles';
            mainLabel.className = 'samples-tray-label';
            puzzleSamplesTray.appendChild(mainLabel);

            for (const categoryName in puzzleSamples) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'sample-category';
                const categoryHeader = document.createElement('h4');
                categoryHeader.textContent = categoryName;
                categoryDiv.appendChild(categoryHeader);

                puzzleSamples[categoryName].forEach(sample => {
                    const sampleCard = make_puzzle_card(sample);
                    sampleCard.addEventListener('click', () => {
                        if (codeMirrorEditor) {
                            saveInputState(codeMirrorEditor.getValue());
                            codeMirrorEditor.setValue(sample.value);
                        }

                        // Clear output panel and reset stats
                        outputText.innerHTML = '';
                        worlds_found = 0;
                        solve_start_time = null;
                        solve_end_time = null;
                        updateOutputStats();
                        globalThis.stopRequested = true; // Stop any ongoing solve

                        puzzleSamplesTrayWrapper.classList.remove('visible');
                        characterSamplesTrayWrapper.classList.remove('visible');
                        showHidePuzzleTrayContent();
                        showHideCharacterTrayContent();
                        // if (codeMirrorEditor) codeMirrorEditor.focus();
                    });
                    categoryDiv.appendChild(sampleCard);
                });
                puzzleSamplesTray.appendChild(categoryDiv);
            }
        }

        function populateShortSamplesTray() {
            characterSamplesTray.innerHTML = '';
            const mainLabel = document.createElement('h3');
            mainLabel.textContent = 'Characters';
            mainLabel.className = 'samples-tray-label';
            characterSamplesTray.appendChild(mainLabel);

            for (const categoryName in characterSamples) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'sample-category';
                const categoryHeader = document.createElement('h4');
                categoryHeader.textContent = categoryName;
                categoryDiv.appendChild(categoryHeader);

                characterSamples[categoryName].forEach(sample => {
                    const sampleCard = document.createElement('div');
                    sampleCard.className = 'short-sample-item';

                    const titleElement = document.createElement('div');
                    titleElement.className = 'short-sample-title';
                    titleElement.textContent = sample.name;
                    if (categoryName == 'Demons' || categoryName == 'Minions') {
                        titleElement.style.color = '#f88';
                    }

                    const snippetElement = document.createElement('div');
                    snippetElement.className = 'short-sample-snippet';
                    snippetElement.textContent = sample.value;

                    sampleCard.appendChild(titleElement);
                    sampleCard.appendChild(snippetElement);

                    sampleCard.addEventListener('click', () => {
                        if (codeMirrorEditor) {
                            const doc = codeMirrorEditor.getDoc();
                            const cursor = doc.getCursor();

                            const currentLineContent = doc.getLine(cursor.line);
                            const baseIndentMatch = currentLineContent.match(/^(\s*)/);
                            const baseIndent = baseIndentMatch ? baseIndentMatch[0] : "";

                            const sampleValueToInsert = sample.value;
                            const sampleLines = sampleValueToInsert.split('\n');

                            let textToInsert = "";

                            if (sampleLines.length > 0) {
                                textToInsert += sampleLines[0];
                                for (let i = 1; i < sampleLines.length; i++) {
                                    textToInsert += "\n" + baseIndent + sampleLines[i];
                                }
                            } else {
                                textToInsert = sampleValueToInsert;
                            }

                            doc.replaceRange(textToInsert, cursor);
                            // codeMirrorEditor.focus();
                        }
                    });
                    categoryDiv.appendChild(sampleCard);
                });
                characterSamplesTray.appendChild(categoryDiv);
            }
        }

        undoInputButton.addEventListener('click', () => {
            codeMirrorEditor.undo();
        });

        redoInputButton.addEventListener('click', () => {
            codeMirrorEditor.redo();
        });

        shareButton.addEventListener('click', () => {
            let url = new URL(window.location);
            let puzzle = LZString.compressToEncodedURIComponent(
                codeMirrorEditor.getValue()
            );
            let payload = `${url.origin}${url.pathname}?puzzle=${puzzle}`;
            function pulseMessage(message) {
                shareSuccessMsg.innerText = message;
                shareSuccessMsg.style.transition = '0.3s';
                shareSuccessMsg.style.display = 'block';
                shareSuccessMsg.style.opacity = '1';
                setTimeout(() => {
                    shareSuccessMsg.style.transition = '0.4s ease-out';
                    shareSuccessMsg.style.opacity = '0';
                    setTimeout(() => {
                        shareSuccessMsg.style.display = 'none';
                    }, 500);
                }, 1000);
            }
            navigator.clipboard.writeText(payload).then(function () {
                pulseMessage('‚úÖ URL copied to clipboard.');
            }, function (err) {
                pulseMessage(`‚ùå Link generation failed...`);
            });
        });


        puzzleSamplesTimeout = null;
        function showHidePuzzleTrayContent() {
            if (puzzleSamplesTimeout != null) clearTimeout(puzzleSamplesTimeout);
            if (puzzleSamplesTrayWrapper.classList.contains('visible')) {
                puzzleSamplesTray.style.display = 'flex';
                return;
            }
            puzzleSamplesTimeout = setTimeout(
                () => { puzzleSamplesTray.style.display = 'none'; },
                700,
            );
        }

        characterSamplesTimeout = null;
        function showHideCharacterTrayContent() {
            if (characterSamplesTimeout != null) clearTimeout(characterSamplesTimeout);
            if (characterSamplesTrayWrapper.classList.contains('visible')) {
                characterSamplesTray.style.display = 'flex';
                return;
            }
            characterSamplesTimeout = setTimeout(
                () => { characterSamplesTray.style.display = 'none'; },
                700,
            );
        }

        toggleLongSamplesTrayButton.addEventListener('click', () => {
            puzzleSamplesTrayWrapper.classList.toggle('visible');
            showHidePuzzleTrayContent();
        });
        toggleShortSamplesTrayButton.addEventListener('click', () => {
            characterSamplesTrayWrapper.classList.toggle('visible');
            showHideCharacterTrayContent();
        });


        function updateOutputStats() {
            let time = '0';
            if (solve_start_time !== null) {
                time = ((solve_end_time - solve_start_time) / 1000).toFixed(1);
                outputInfoBar.textContent = `Solutions: ${worlds_found} | Time taken: ${time}s`;
            } else {
                outputInfoBar.textContent = `Solutions: - | Time taken: --`;
            }
        }


        function showUserMessage(message) {
            messageBoxText.textContent = message;
            messageBoxOverlay.classList.add('show');
        }
        messageBoxOkButton.addEventListener('click', () => messageBoxOverlay.classList.remove('show'));


        infoButton.addEventListener('click', () => {
            infoModal.classList.add('show');
        });

        closeInfoModalButton.addEventListener('click', () => {
            infoModal.classList.remove('show');
        });


        takingTooLongPopup.addEventListener('click', () => {
            clearTimeout(takingTooLongTimerId);
            longTransformInfoDialogOverlay.classList.add('show');
        });

        closeLongTransformInfoDialogButton.addEventListener('click', () => {
            longTransformInfoDialogOverlay.classList.remove('show');
        });

        helpButton.addEventListener('click', () => {
            helpModal.classList.add('show');
        });

        closeHelpModalButton.addEventListener('click', () => {
            helpModal.classList.remove('show');
        });

        // Close modals on overlay click
        [infoModal, helpModal, longTransformInfoDialogOverlay, messageBoxOverlay].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });
        });

        globalThis.stopRequested = false;

        worlds_found = 0;
        solve_start_time = null;
        solve_end_time = null;
        time_ticker_interval = null;
        function GUI_startProcessing() {
            globalThis.stopRequested = false;
            outputText.innerHTML = '';
            worlds_found = 0;
            solve_start_time = new Date().getTime();
            solve_end_time = new Date().getTime();
            time_ticker_interval = setInterval(
                () => {
                    solve_end_time = new Date().getTime();
                    updateOutputStats()
                },
                100,
            )
            applyButton.style.display = 'none';
            stopButton.style.display = 'flex';
            stopButtonSpinner.style.display = 'inline-block';
            stopButton.disabled = false;
            stopButtonText.innerText = 'Stop';
            console.log('GUI_startProcessing')

            clearTimeout(takingTooLongTimerId);
            takingTooLongPopup.style.display = 'none';
            takingTooLongTimerId = setTimeout(() => {
                if (stopButton.style.display === 'flex') {
                    takingTooLongPopup.style.display = 'block';
                }
            }, 10000);
        }

        function GUI_worldFound(world, stateHtml) {
            let cleaned = String(world).trim();
            if (cleaned.startsWith("World(")) {
                cleaned = cleaned.substring(6).trim();
            }
            if (cleaned.endsWith(")")) {
                cleaned = cleaned.substring(0, cleaned.length - 1).trim();
            }

            const row = document.createElement('div');
            row.className = 'solution-row';
            row.innerHTML = cleaned;
            row.dataset.stateHtml = stateHtml;

            row.addEventListener('click', () => {
                if (row.classList.contains('selected')) {
                    // Toggle off if already selected
                    row.classList.remove('selected');
                    // Restore base puzzle visualization
                    update_render();
                } else {
                    // Highlight selected row
                    document.querySelectorAll('.solution-row').forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');

                    // Update render panel with this solution's world state
                    const renderDisplay = document.getElementById('renderDisplay');
                    renderDisplay.innerHTML = stateHtml;

                    // Ensure scaling is correct for the new render
                    setTimeout(updatePuzzleScaling, 0);
                }
            });

            outputText.appendChild(row);

            outputText.scrollTop = outputText.scrollHeight;
            worlds_found += 1;
            solve_end_time = new Date().getTime();
            updateOutputStats();
        }

        function GUI_returnError(message) {
            const row = document.createElement('div');
            row.className = 'error-row';
            row.innerHTML = String(message);
            outputText.appendChild(row);

            outputText.scrollTop = outputText.scrollHeight;
        }

        function GUI_finishedProcessing() {
            clearTimeout(takingTooLongTimerId);
            takingTooLongPopup.style.display = 'none';
            applyButton.style.display = 'flex';
            stopButton.style.display = 'none';
            stopButtonSpinner.style.display = 'none';
            clearInterval(time_ticker_interval);
            solve_end_time = new Date().getTime();
            updateOutputStats();
        }

        async function update_render() {
            if (!window.render_puzzle_api) return;

            try {
                const rawResult = await window.render_puzzle_api(codeMirrorEditor.getValue());
                if (!rawResult) return;

                const res = rawResult.to_js ? rawResult.to_js() : rawResult;
                const isMap = res instanceof Map;

                const success = isMap ? res.get('success') : res.success;

                const display = document.getElementById('renderDisplay');
                const toast = document.getElementById('renderErrorToast');
                const text = document.getElementById('renderErrorText');

                if (success) {
                    const newHtml = isMap ? res.get('html') : res.html;
                    if (display.innerHTML !== newHtml) {
                        display.innerHTML = newHtml;
                        // Clear solution selection when base puzzle is re-rendered
                        document.querySelectorAll('.solution-row').forEach(r => r.classList.remove('selected'));
                        setTimeout(updatePuzzleScaling, 0);
                    }
                    toast.style.display = 'none';
                } else {
                    const error = isMap ? res.get('error') : res.error;
                    if (error) {
                        const errorLines = String(error).trim().split('\n');

                        let displayError = "Render failed";
                        let lineNo = "";

                        // Look for the line number (python style: 'line X') - choose the last one mentioned
                        // This identifies the error in the user's puzzle definition, not the boiler-plate
                        for (let i = errorLines.length - 1; i >= 0; i--) {
                            const match = errorLines[i].match(/line (\d+)/);
                            if (match) {
                                lineNo = " (Line " + match[1] + ")";
                                break;
                            }
                        }

                        // Filter for the actual message (last non-noise line)
                        const filteredLines = errorLines
                            .filter(l => l.trim().length > 0)
                            .filter(l => !l.includes('File "') && !l.includes('line '));

                        if (filteredLines.length > 0) {
                            displayError = filteredLines[filteredLines.length - 1];
                            if (displayError.includes(': ')) {
                                displayError = displayError.split(': ').slice(1).join(': ');
                            }
                        }

                        text.innerText = "Render failed: " + displayError + lineNo;
                        toast.style.display = 'flex'; // Use flex now for alignment
                    }
                }
            } catch (e) {
                console.error("Critical error in update_render:", e);
            }
        }

        window.update_render = update_render;

        // Handle toast dismissal
        document.getElementById('closeToastBtn').addEventListener('click', () => {
            document.getElementById('renderErrorToast').style.display = 'none';
        });


        stopButton.addEventListener('click', () => {
            if (globalThis.stopRequested) return;
            globalThis.stopRequested = true;
            stopButtonSpinner.style.display = 'inline-block';
            stopButtonText.innerText = 'Stopping'
            console.log("Stop requested by user.");
        });

        document.addEventListener('keydown', (event) => {
            const isInputFocused = codeMirrorEditor && codeMirrorEditor.hasFocus();

            if (isInputFocused) {
                if (event.ctrlKey && event.key === 'Enter' && applyButton.style.display !== 'none') {
                    event.preventDefault();
                    applyTransformation();
                } else if (event.ctrlKey && (event.key === 'z' || event.key === 'Z')) {
                    event.preventDefault();
                    undoInputButton.click();
                } else if (event.ctrlKey && (event.key === 'y' || event.key === 'Y')) {
                    event.preventDefault();
                    redoInputButton.click();
                    codeMirrorEditor.redo();
                } else if (event.ctrlKey && event.key === '/') {
                    codeMirrorEditor.toggleComment();
                }
            }
        });

        // --- Initialization ---
        populateLongSamplesTray();
        populateShortSamplesTray();
        updateOutputStats();

        // Responsive scaling for puzzle visualization
        const renderDisplay = document.getElementById('renderDisplay');
        const updatePuzzleScaling = () => {
            if (!renderDisplay) return;
            const container = renderDisplay.querySelector('.puzzle-app-container');
            if (!container) return;

            const style = getComputedStyle(container);
            const internalWidth = parseFloat(style.getPropertyValue('--puzzle-internal-width')) || 1000;
            const internalHeight = parseFloat(style.getPropertyValue('--puzzle-internal-height')) || 1000;

            const rect = renderDisplay.getBoundingClientRect();
            const availW = rect.width;
            const availH = rect.height;

            const scaleW = availW / internalWidth;
            const scaleH = (availH - 20) / internalHeight; // 20px buffer

            const scale = Math.min(scaleW, scaleH);
            const targetWidth = internalWidth * scale;

            document.documentElement.style.setProperty('--puzzle-scale', scale);
            document.documentElement.style.setProperty('--puzzle-target-width', targetWidth + 'px');
            document.documentElement.style.setProperty('--puzzle-internal-width', internalWidth + 'px');
        };
        window.updatePuzzleScaling = updatePuzzleScaling;

        const resizeObserver = new ResizeObserver(entries => {
            updatePuzzleScaling();
        });
        if (renderDisplay) {
            resizeObserver.observe(renderDisplay);
        }
        // Focus is handled by CodeMirror after initialization in DOMContentLoaded

        // Panel Resizing Logic
        const vResizer = document.getElementById('vResizer');
        const hResizer = document.getElementById('hResizer');
        const inputPanel = document.getElementById('inputPanel');
        // renderPanel is already declared above
        const outputPanel = document.getElementById('outputPanel');
        const rightColumn = document.querySelector('.right-column-container');
        const panelsContainer = document.querySelector('.panels-container');

        let isResizingV = false;
        let isResizingH = false;

        const updateVResizerHandle = () => {
            if (!vResizer || !renderPanel || !rightColumn) return;
            // rightColumn.offsetTop should be 0 if they align at top, but better to be explicit
            const localHandleTop = rightColumn.offsetTop + renderPanel.offsetTop + (renderPanel.offsetHeight / 2) - 15;
            vResizer.style.setProperty('--handle-top', `${localHandleTop}px`);
        };

        if (vResizer && hResizer && inputPanel && renderPanel && outputPanel && rightColumn && panelsContainer) {
            const startResizingV = (e) => {
                isResizingV = true;
                document.body.classList.add('resizing', 'resizing-v');
                vResizer.classList.add('dragging');
                if (e.cancelable) e.preventDefault();
            };

            const startResizingH = (e) => {
                isResizingH = true;
                document.body.classList.add('resizing', 'resizing-h');
                hResizer.classList.add('dragging');
                if (e.cancelable) e.preventDefault();
            };

            vResizer.addEventListener('mousedown', startResizingV);
            vResizer.addEventListener('touchstart', startResizingV, { passive: false });

            hResizer.addEventListener('mousedown', startResizingH);
            hResizer.addEventListener('touchstart', startResizingH, { passive: false });

            const handleMove = (clientX, clientY) => {
                if (!isResizingV && !isResizingH) return;

                requestAnimationFrame(() => {
                    if (isResizingV) {
                        const containerRect = panelsContainer.getBoundingClientRect();
                        const newWidth = clientX - containerRect.left;

                        // Constraints
                        if (newWidth > 200 && newWidth < containerRect.width - 400) {
                            inputPanel.style.flex = 'none';
                            inputPanel.style.width = `${newWidth}px`;
                        }
                    }

                    if (isResizingH) {
                        const columnRect = rightColumn.getBoundingClientRect();
                        const newHeight = clientY - columnRect.top;

                        // Constraints
                        if (newHeight > 150 && newHeight < columnRect.height - 100) {
                            renderPanel.style.flex = 'none';
                            renderPanel.style.height = `${newHeight}px`;
                            outputPanel.style.flex = '1';
                        }
                        updateVResizerHandle();
                    }
                });
            };

            document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
            document.addEventListener('touchmove', (e) => {
                if (isResizingV || isResizingH) {
                    const touch = e.touches[0];
                    handleMove(touch.clientX, touch.clientY);
                    if (e.cancelable) e.preventDefault();
                }
            }, { passive: false });

            const endResizing = () => {
                if (isResizingV || isResizingH) {
                    isResizingV = false;
                    isResizingH = false;
                    document.body.classList.remove('resizing', 'resizing-v', 'resizing-h');
                    vResizer.classList.remove('dragging');
                    hResizer.classList.remove('dragging');
                }
            };

            document.addEventListener('mouseup', endResizing);
            document.addEventListener('touchend', endResizing);
            document.addEventListener('touchcancel', endResizing);

            window.addEventListener('resize', updateVResizerHandle);
            setTimeout(updateVResizerHandle, 100);

            // Hook into try toggles
            document.getElementById('toggleLongSamplesTrayButton')?.addEventListener('click', () => setTimeout(updateVResizerHandle, 300));
            document.getElementById('toggleShortSamplesTrayButton')?.addEventListener('click', () => setTimeout(updateVResizerHandle, 300));
        }

        // ========== Puzzle Builder Logic ==========

        const builderState = {
            players: [],
            hiddenCharacters: [],
            hiddenSelf: [],
            dayEvents: {},
            nightDeaths: {},
            allowDuplicateTokens: false
        };

        // Tab switching
        document.querySelectorAll('.input-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.input-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.input-tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                const tabId = tab.dataset.tab;
                if (tabId === 'text') {
                    document.getElementById('textInputContainer').classList.add('active');
                    // Refresh CodeMirror when switching to text tab
                    if (codeMirrorEditor) {
                        setTimeout(() => codeMirrorEditor.refresh(), 0);
                    }
                } else {
                    document.getElementById('builderInputContainer').classList.add('active');
                }
            });
        });

        // Start builder button
        document.getElementById('startBuilderBtn').addEventListener('click', () => {
            const namesInput = document.getElementById('playerNamesInput').value.trim();
            if (!namesInput) {
                alert('Please enter player names');
                return;
            }
            const names = namesInput.split(',').map(n => n.trim()).filter(n => n);
            if (names.length < 2) {
                alert('Please enter at least 2 player names');
                return;
            }
            initializeBuilder(names);
        });

        function initializeBuilder(playerNames) {
            // Reset builder state
            builderState.players = playerNames.map((name, index) => ({
                id: index,
                name: name,
                claim: '',
                nightInfo: {},
                dayInfo: {}
            }));
            builderState.hiddenCharacters = [];
            builderState.hiddenSelf = [];
            builderState.dayEvents = {};
            builderState.nightDeaths = {};
            builderState.allowDuplicateTokens = false;

            // Render player rows
            renderBuilderPlayers();

            // Show global settings and actions
            document.getElementById('builderGlobals').style.display = 'block';
            document.getElementById('builderActions').style.display = 'block';
        }

        function renderBuilderPlayers() {
            const container = document.getElementById('builderPlayers');
            container.innerHTML = '';

            builderState.players.forEach((player, idx) => {
                const row = document.createElement('div');
                row.className = 'builder-player-row';
                row.innerHTML = `
                    <div class="builder-player-header">
                        <span class="builder-player-name">${player.name}</span>
                        <div class="builder-player-claim">
                            <label>claim=</label>
                            <select class="builder-select builder-claim-select" data-player="${idx}">
                                <option value="">-- Select --</option>
                                ${renderCharacterOptions()}
                            </select>
                        </div>
                    </div>
                    <div class="builder-info-section">
                        <div class="builder-info-header">
                            <span class="builder-info-title">Night Info</span>
                            <button class="builder-add-btn" data-player="${idx}" data-phase="night">+ Add</button>
                        </div>
                        <div class="builder-info-items" id="nightInfo-${idx}"></div>
                    </div>
                    <div class="builder-info-section">
                        <div class="builder-info-header">
                            <span class="builder-info-title">Day Info</span>
                            <button class="builder-add-btn" data-player="${idx}" data-phase="day">+ Add</button>
                        </div>
                        <div class="builder-info-items" id="dayInfo-${idx}"></div>
                    </div>
                `;
                container.appendChild(row);

                // Set initial claim value if exists
                const claimSelect = row.querySelector('.builder-claim-select');
                if (player.claim) {
                    claimSelect.value = player.claim;
                }

                // Handle claim change
                claimSelect.addEventListener('change', (e) => {
                    builderState.players[idx].claim = e.target.value;
                    updateClaimSelectColor(claimSelect);
                });
            });

            // Add event listeners for add buttons
            container.querySelectorAll('.builder-add-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const playerIdx = parseInt(btn.dataset.player);
                    const phase = btn.dataset.phase;
                    addInfoItem(playerIdx, phase);
                });
            });
        }

        function renderCharacterOptions() {
            let html = '';
            for (const [category, chars] of Object.entries(GuiSchema.characters)) {
                html += `<optgroup label="${category}">`;
                chars.forEach(char => {
                    const colorClass = GuiSchema.getCharacterColorClass(char);
                    html += `<option value="${char}" class="${colorClass}">${char}</option>`;
                });
                html += '</optgroup>';
            }
            return html;
        }

        function updateClaimSelectColor(select) {
            select.classList.remove('townsfolk-character', 'outsider-character', 'evil-character');
            if (select.value) {
                select.classList.add(GuiSchema.getCharacterColorClass(select.value));
            }
        }

        function renderPlayerOptions() {
            return builderState.players.map(p =>
                `<option value="${p.name}">${p.name}</option>`
            ).join('');
        }

        function addInfoItem(playerIdx, phase) {
            const player = builderState.players[playerIdx];
            const infoDict = phase === 'night' ? player.nightInfo : player.dayInfo;
            const types = GuiSchema.getAllInfoTypes(phase);

            // Find next day number
            const existingDays = Object.keys(infoDict).map(Number);
            const nextDay = existingDays.length > 0 ? Math.max(...existingDays) + 1 : 1;

            // Create info item with default type
            const itemId = Date.now();
            if (!infoDict[nextDay]) {
                infoDict[nextDay] = [];
            }
            infoDict[nextDay].push({
                id: itemId,
                type: '',
                fields: {}
            });

            renderInfoItems(playerIdx, phase);
        }

        function renderInfoItems(playerIdx, phase) {
            const player = builderState.players[playerIdx];
            const infoDict = phase === 'night' ? player.nightInfo : player.dayInfo;
            const container = document.getElementById(`${phase}Info-${playerIdx}`);
            container.innerHTML = '';

            const types = GuiSchema.getAllInfoTypes(phase);
            const sortedDays = Object.keys(infoDict).sort((a, b) => Number(a) - Number(b));

            sortedDays.forEach(day => {
                const items = infoDict[day];
                items.forEach((item, itemIdx) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'builder-info-item';
                    itemEl.innerHTML = `
                        <input type="number" class="builder-number-input builder-day-input" 
                            value="${day}" min="1" max="99" data-item-id="${item.id}">
                        <select class="builder-select builder-info-type-select" data-item-id="${item.id}">
                            <option value="">-- Info Type --</option>
                            ${types.map(t => `<option value="${t.key}">${t.key}</option>`).join('')}
                        </select>
                        <div class="builder-field-group builder-info-fields" data-item-id="${item.id}"></div>
                        <button class="builder-remove-btn" data-item-id="${item.id}">‚úï</button>
                    `;
                    container.appendChild(itemEl);

                    // Set type if exists
                    const typeSelect = itemEl.querySelector('.builder-info-type-select');
                    if (item.type) {
                        typeSelect.value = item.type;
                        renderInfoFields(itemEl.querySelector('.builder-info-fields'), item.type, item.fields);
                    }

                    // Handle type change
                    typeSelect.addEventListener('change', (e) => {
                        item.type = e.target.value;
                        item.fields = {};
                        renderInfoFields(itemEl.querySelector('.builder-info-fields'), e.target.value, item.fields);
                    });

                    // Handle day change
                    itemEl.querySelector('.builder-day-input').addEventListener('change', (e) => {
                        const oldDay = day;
                        const newDay = e.target.value;
                        if (oldDay !== newDay) {
                            // Move item to new day
                            const idx = infoDict[oldDay].findIndex(i => i.id === item.id);
                            infoDict[oldDay].splice(idx, 1);
                            if (infoDict[oldDay].length === 0) {
                                delete infoDict[oldDay];
                            }
                            if (!infoDict[newDay]) {
                                infoDict[newDay] = [];
                            }
                            infoDict[newDay].push(item);
                            renderInfoItems(playerIdx, phase);
                        }
                    });

                    // Handle remove
                    itemEl.querySelector('.builder-remove-btn').addEventListener('click', () => {
                        const idx = infoDict[day].findIndex(i => i.id === item.id);
                        infoDict[day].splice(idx, 1);
                        if (infoDict[day].length === 0) {
                            delete infoDict[day];
                        }
                        renderInfoItems(playerIdx, phase);
                    });
                });
            });
        }

        function renderInfoFields(container, infoType, fieldValues) {
            container.innerHTML = '';
            if (!infoType) return;

            const allTypes = { ...GuiSchema.infoTypes.night, ...GuiSchema.infoTypes.day };
            const typeDef = allTypes[infoType];
            if (!typeDef || !typeDef.fields) return;

            typeDef.fields.forEach(field => {
                const wrapper = document.createElement('div');
                wrapper.className = 'builder-field-group';

                let input;
                switch (field.type) {
                    case 'player':
                        input = document.createElement('select');
                        input.className = 'builder-select';
                        input.innerHTML = `<option value="">--</option>${renderPlayerOptions()}`;
                        break;
                    case 'character':
                        input = document.createElement('select');
                        input.className = 'builder-select';
                        if (field.category) {
                            input.innerHTML = `<option value="">--</option>` +
                                GuiSchema.characters[field.category].map(c =>
                                    `<option value="${c}">${c}</option>`
                                ).join('');
                        } else {
                            input.innerHTML = `<option value="">--</option>${renderCharacterOptions()}`;
                        }
                        break;
                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'builder-number-input';
                        input.min = field.min || 0;
                        input.max = field.max || 99;
                        break;
                    case 'bool':
                        input = document.createElement('select');
                        input.className = 'builder-select';
                        input.innerHTML = '<option value="True">True</option><option value="False">False</option>';
                        break;
                    default:
                        input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'builder-text-input';
                        input.style.width = '100px';
                }

                input.dataset.fieldName = field.name;

                // Set value if exists
                if (fieldValues[field.name] !== undefined) {
                    input.value = fieldValues[field.name];
                }

                // Handle change
                input.addEventListener('change', (e) => {
                    fieldValues[field.name] = e.target.value;
                });

                const label = document.createElement('label');
                label.textContent = field.label + ':';
                wrapper.appendChild(label);
                wrapper.appendChild(input);
                container.appendChild(wrapper);
            });
        }

        // Hidden characters add button
        document.querySelector('.builder-add-hidden-char').addEventListener('click', () => {
            addHiddenCharacterSelect('hiddenCharsContainer', builderState.hiddenCharacters);
        });

        document.querySelector('.builder-add-hidden-self').addEventListener('click', () => {
            addHiddenCharacterSelect('hiddenSelfContainer', builderState.hiddenSelf);
        });

        function addHiddenCharacterSelect(containerId, array) {
            const container = document.getElementById(containerId);
            const select = document.createElement('select');
            select.className = 'builder-select';
            select.innerHTML = `<option value="">--</option>${renderCharacterOptions()}`;

            select.addEventListener('change', (e) => {
                if (e.target.value) {
                    array.push(e.target.value);
                    // Replace select with tag
                    const tag = document.createElement('span');
                    const isEvil = GuiSchema.characters.Minions.includes(e.target.value) ||
                        GuiSchema.characters.Demons.includes(e.target.value);
                    tag.className = `builder-tag ${isEvil ? 'evil' : 'good'}`;
                    tag.innerHTML = `${e.target.value} <span class="remove-tag">√ó</span>`;
                    tag.querySelector('.remove-tag').addEventListener('click', () => {
                        const idx = array.indexOf(e.target.value);
                        if (idx > -1) array.splice(idx, 1);
                        tag.remove();
                    });
                    select.replaceWith(tag);
                }
            });

            container.appendChild(select);
        }

        // Day events add button
        document.querySelector('.builder-add-day-event').addEventListener('click', () => {
            addDayEvent();
        });

        function addDayEvent() {
            const container = document.getElementById('dayEventsContainer');
            const eventId = Date.now();

            // Find next day number
            const existingDays = Object.keys(builderState.dayEvents).map(Number);
            const nextDay = existingDays.length > 0 ? Math.max(...existingDays) + 1 : 1;

            if (!builderState.dayEvents[nextDay]) {
                builderState.dayEvents[nextDay] = [];
            }
            builderState.dayEvents[nextDay].push({ id: eventId, type: '', fields: {} });

            const row = document.createElement('div');
            row.className = 'builder-event-row';
            row.dataset.eventId = eventId;
            row.innerHTML = `
                <input type="number" class="builder-number-input builder-day-input" value="${nextDay}" min="1" max="99">
                <select class="builder-select builder-event-type-select">
                    <option value="">-- Event --</option>
                    ${Object.keys(GuiSchema.dayEvents).map(e => `<option value="${e}">${e}</option>`).join('')}
                </select>
                <div class="builder-field-group builder-event-fields"></div>
                <button class="builder-remove-btn">‚úï</button>
            `;
            container.appendChild(row);

            row.querySelector('.builder-event-type-select').addEventListener('change', (e) => {
                const event = findEventById(eventId);
                if (event) {
                    event.type = e.target.value;
                    event.fields = {};
                    renderEventFields(row.querySelector('.builder-event-fields'), e.target.value, event.fields);
                }
            });

            row.querySelector('.builder-remove-btn').addEventListener('click', () => {
                removeEventById(eventId);
                row.remove();
            });
        }

        function findEventById(eventId) {
            for (const day of Object.keys(builderState.dayEvents)) {
                const event = builderState.dayEvents[day].find(e => e.id === eventId);
                if (event) return event;
            }
            return null;
        }

        function removeEventById(eventId) {
            for (const day of Object.keys(builderState.dayEvents)) {
                const idx = builderState.dayEvents[day].findIndex(e => e.id === eventId);
                if (idx > -1) {
                    builderState.dayEvents[day].splice(idx, 1);
                    if (builderState.dayEvents[day].length === 0) {
                        delete builderState.dayEvents[day];
                    }
                    return;
                }
            }
        }

        function renderEventFields(container, eventType, fieldValues) {
            container.innerHTML = '';
            if (!eventType) return;

            const typeDef = GuiSchema.dayEvents[eventType];
            if (!typeDef || !typeDef.fields) return;

            typeDef.fields.forEach(field => {
                const wrapper = document.createElement('div');
                wrapper.className = 'builder-field-group';

                let input;
                switch (field.type) {
                    case 'player':
                        input = document.createElement('select');
                        input.className = 'builder-select';
                        input.innerHTML = `<option value="">--</option>${renderPlayerOptions()}`;
                        break;
                    case 'bool':
                        input = document.createElement('select');
                        input.className = 'builder-select';
                        input.innerHTML = '<option value="True">True</option><option value="False">False</option>';
                        if (field.default !== undefined) {
                            input.value = field.default ? 'True' : 'False';
                            fieldValues[field.name] = field.default ? 'True' : 'False';
                        }
                        break;
                    default:
                        input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'builder-text-input';
                        input.style.width = '80px';
                }

                input.dataset.fieldName = field.name;
                if (fieldValues[field.name] !== undefined) {
                    input.value = fieldValues[field.name];
                }

                input.addEventListener('change', (e) => {
                    fieldValues[field.name] = e.target.value;
                });

                const label = document.createElement('label');
                label.textContent = field.label + ':';
                wrapper.appendChild(label);
                wrapper.appendChild(input);
                container.appendChild(wrapper);
            });
        }

        // Night deaths add button
        document.querySelector('.builder-add-night-death').addEventListener('click', () => {
            addNightDeath();
        });

        function addNightDeath() {
            const container = document.getElementById('nightDeathsContainer');
            const deathId = Date.now();

            const existingNights = Object.keys(builderState.nightDeaths).map(Number);
            const nextNight = existingNights.length > 0 ? Math.max(...existingNights) + 1 : 2;

            builderState.nightDeaths[nextNight] = { id: deathId, player: '' };

            const row = document.createElement('div');
            row.className = 'builder-event-row';
            row.dataset.deathId = deathId;
            row.innerHTML = `
                <span class="builder-day-num">Night</span>
                <input type="number" class="builder-number-input" value="${nextNight}" min="1" max="99">
                <span>:</span>
                <select class="builder-select">
                    <option value="">-- Player --</option>
                    ${renderPlayerOptions()}
                </select>
                <button class="builder-remove-btn">‚úï</button>
            `;
            container.appendChild(row);

            row.querySelector('select').addEventListener('change', (e) => {
                const night = row.querySelector('input[type="number"]').value;
                if (builderState.nightDeaths[night]) {
                    builderState.nightDeaths[night].player = e.target.value;
                }
            });

            row.querySelector('.builder-remove-btn').addEventListener('click', () => {
                const night = row.querySelector('input[type="number"]').value;
                delete builderState.nightDeaths[night];
                row.remove();
            });
        }

        // Duplicate tokens checkbox
        document.getElementById('allowDuplicateTokens').addEventListener('change', (e) => {
            builderState.allowDuplicateTokens = e.target.checked;
        });

        // Generate code button
        document.getElementById('generateCodeBtn').addEventListener('click', () => {
            const issues = findIncompleteFields();
            if (issues.length > 0) {
                showIncompleteFieldsModal(issues);
            } else {
                doGenerateCode();
            }
        });

        function findIncompleteFields() {
            const issues = [];

            // Check each player
            builderState.players.forEach((player, idx) => {
                if (!player.claim) {
                    issues.push(`Player "${player.name}" has no character claim selected`);
                }

                // Check night info
                Object.keys(player.nightInfo).forEach(day => {
                    player.nightInfo[day].forEach((item, itemIdx) => {
                        if (!item.type) {
                            issues.push(`Player "${player.name}" has an empty night info type (day ${day})`);
                        } else {
                            const typeDef = GuiSchema.infoTypes.night[item.type];
                            if (typeDef) {
                                typeDef.fields.forEach(field => {
                                    if (!field.optional && !item.fields[field.name]) {
                                        issues.push(`Player "${player.name}": ${item.type} missing "${field.label}" (day ${day})`);
                                    }
                                });
                            }
                        }
                    });
                });

                // Check day info
                Object.keys(player.dayInfo).forEach(day => {
                    player.dayInfo[day].forEach((item, itemIdx) => {
                        if (!item.type) {
                            issues.push(`Player "${player.name}" has an empty day info type (day ${day})`);
                        } else {
                            const typeDef = GuiSchema.infoTypes.day[item.type];
                            if (typeDef) {
                                typeDef.fields.forEach(field => {
                                    if (!field.optional && !item.fields[field.name]) {
                                        issues.push(`Player "${player.name}": ${item.type} missing "${field.label}" (day ${day})`);
                                    }
                                });
                            }
                        }
                    });
                });
            });

            // Check day events
            Object.keys(builderState.dayEvents).forEach(day => {
                builderState.dayEvents[day].forEach(event => {
                    if (!event.type) {
                        issues.push(`Day ${day}: empty event type`);
                    } else {
                        const typeDef = GuiSchema.dayEvents[event.type];
                        if (typeDef) {
                            typeDef.fields.forEach(field => {
                                if (!field.optional && !event.fields[field.name]) {
                                    issues.push(`Day ${day} ${event.type}: missing "${field.label}"`);
                                }
                            });
                        }
                    }
                });
            });

            // Check night deaths
            Object.keys(builderState.nightDeaths).forEach(night => {
                if (!builderState.nightDeaths[night].player) {
                    issues.push(`Night ${night}: no player selected for death`);
                }
            });

            return issues;
        }

        function showIncompleteFieldsModal(issues) {
            const overlay = document.getElementById('incompleteFieldsModalOverlay');
            const message = document.getElementById('incompleteFieldsMessage');

            // Show first 5 issues to avoid overwhelming
            const displayIssues = issues.slice(0, 5);
            let html = 'The following fields are incomplete:<ul style="margin: 0.5rem 0; padding-left: 1.5rem;">';
            displayIssues.forEach(issue => {
                html += `<li style="margin-bottom: 0.25rem;">${issue}</li>`;
            });
            if (issues.length > 5) {
                html += `<li style="color: #9ca3af;">...and ${issues.length - 5} more issues</li>`;
            }
            html += '</ul>';

            message.innerHTML = html;
            overlay.classList.add('show');
        }

        document.getElementById('closeIncompleteFieldsModal').addEventListener('click', () => {
            document.getElementById('incompleteFieldsModalOverlay').classList.remove('show');
        });

        document.getElementById('incompleteFieldsCancelBtn').addEventListener('click', () => {
            document.getElementById('incompleteFieldsModalOverlay').classList.remove('show');
        });

        document.getElementById('incompleteFieldsGenerateBtn').addEventListener('click', () => {
            document.getElementById('incompleteFieldsModalOverlay').classList.remove('show');
            doGenerateCode();
        });

        function doGenerateCode() {
            const code = generatePuzzleCode();
            if (codeMirrorEditor) {
                codeMirrorEditor.setValue(code);
            }
            // Switch to text tab
            document.getElementById('textTabBtn').click();
        }

        function generatePuzzleCode() {
            const lines = [];

            // Player variable assignments
            const playerVars = builderState.players.map(p => p.name).join(', ');
            lines.push(`${playerVars} = range(${builderState.players.length})`);
            lines.push('');
            lines.push('puzzle = Puzzle(');
            lines.push('    players=[');

            // Player definitions
            builderState.players.forEach((player, idx) => {
                let playerLine = `        Player('${player.name}'`;
                if (player.claim) {
                    playerLine += `, claim=${player.claim}`;
                }

                // Night info
                const nightInfoLines = generateInfoLines(player.nightInfo, 'night');
                if (nightInfoLines.length > 0) {
                    playerLine += `, night_info={`;
                    if (nightInfoLines.length === 1) {
                        playerLine += `\n            ${nightInfoLines[0]}\n        }`;
                    } else {
                        playerLine += '\n';
                        nightInfoLines.forEach(line => {
                            playerLine += `            ${line}\n`;
                        });
                        playerLine += '        }';
                    }
                }

                // Day info
                const dayInfoLines = generateInfoLines(player.dayInfo, 'day');
                if (dayInfoLines.length > 0) {
                    playerLine += `, day_info={`;
                    if (dayInfoLines.length === 1) {
                        playerLine += `\n            ${dayInfoLines[0]}\n        }`;
                    } else {
                        playerLine += '\n';
                        dayInfoLines.forEach(line => {
                            playerLine += `            ${line}\n`;
                        });
                        playerLine += '        }';
                    }
                }

                playerLine += '),';
                lines.push(playerLine);
            });

            lines.push('    ],');

            // Day events
            if (Object.keys(builderState.dayEvents).length > 0) {
                lines.push('    day_events={');
                Object.keys(builderState.dayEvents).sort((a, b) => Number(a) - Number(b)).forEach(day => {
                    const events = builderState.dayEvents[day];
                    const eventStrs = events.map(e => generateEventCode(e)).filter(e => e);
                    if (eventStrs.length === 1) {
                        lines.push(`        ${day}: ${eventStrs[0]},`);
                    } else if (eventStrs.length > 1) {
                        lines.push(`        ${day}: [`);
                        eventStrs.forEach(e => lines.push(`            ${e},`));
                        lines.push('        ],');
                    }
                });
                lines.push('    },');
            }

            // Night deaths
            if (Object.keys(builderState.nightDeaths).length > 0) {
                lines.push('    night_deaths={');
                Object.keys(builderState.nightDeaths).sort((a, b) => Number(a) - Number(b)).forEach(night => {
                    const death = builderState.nightDeaths[night];
                    if (death.player) {
                        lines.push(`        ${night}: ${death.player},`);
                    }
                });
                lines.push('    },');
            }

            // Hidden characters
            if (builderState.hiddenCharacters.length > 0) {
                lines.push(`    hidden_characters=[${builderState.hiddenCharacters.join(', ')}],`);
            }

            // Hidden self
            if (builderState.hiddenSelf.length > 0) {
                lines.push(`    hidden_self=[${builderState.hiddenSelf.join(', ')}],`);
            }

            // Duplicate tokens
            if (builderState.allowDuplicateTokens) {
                lines.push('    allow_duplicate_tokens_in_bag=True,');
            }

            lines.push(')');

            return lines.join('\n');
        }

        function generateInfoLines(infoDict, phase) {
            const lines = [];
            const allTypes = { ...GuiSchema.infoTypes.night, ...GuiSchema.infoTypes.day };

            Object.keys(infoDict).sort((a, b) => Number(a) - Number(b)).forEach(day => {
                const items = infoDict[day];
                items.forEach(item => {
                    if (!item.type) return;
                    const typeDef = allTypes[item.type];
                    if (!typeDef) return;

                    let code = typeDef.template;
                    typeDef.fields.forEach(field => {
                        const value = item.fields[field.name] || '';
                        code = code.replace(`{${field.name}}`, value);
                    });
                    lines.push(`${day}: ${code},`);
                });
            });

            return lines;
        }

        function generateEventCode(event) {
            if (!event.type) return '';
            const typeDef = GuiSchema.dayEvents[event.type];
            if (!typeDef) return '';

            let code = typeDef.template;
            typeDef.fields.forEach(field => {
                const value = event.fields[field.name] || '';
                code = code.replace(`{${field.name}}`, value);
            });
            return code;
        }
    </script>
</body>

</html>