"""This file was vibe-coded with Gemini 3.0 in Antigravity, because UIs are not my jam."""

import argparse
import math
from typing import Mapping
import sys

from clockchecker.core import Puzzle, Player, State
from clockchecker import characters, info, events

# Mapping of character class names to their script folders on the official assets site
TB_CHARACTERS = {
    "Washerwoman", "Librarian", "Investigator", "Chef", "Empath",
    "FortuneTeller", "Undertaker", "Monk", "Ravenkeeper", "Slayer",
    "Soldier", "Mayor", "Butler", "Drunk", "Recluse", "Saint",
    "Imp", "Baron", "Poisoner", "Spy", "ScarletWoman",
}
BMR_CHARACTERS = {
    "Grandmother", "Sailor", "Chambermaid", "Exorcist", "Innkeeper",
    "Gambler", "Gossip", "Courtier", "Professor", "Minstrel",
    "TeaLady", "Pacifist", "Fool", "Tinker", "Moonchild",
    "Goon", "Lunatic", "Godfather", "DevilsAdvocate", "Assassin",
    "Mastermind", "Zombuul", "Pukka", "Shabaloth", "Po",
}
SNV_CHARACTERS = {
    "Clockmaker", "Dreamer", "SnakeCharmer", "Mathematician", "Flowergirl",
    "TownCrier", "Oracle", "Savant", "Artist", "Philosopher",
    "Sage", "Mutant", "Sweetheart", "Klutz", "EvilTwin",
    "Witch", "Cerenovus", "PitHag", "FangGu", "Vortox",
    "NoDashii", "Lleech", "Vigormortis", "Juggler", "Seamstress",
}

def get_character_script(name: str) -> str:
    if name in TB_CHARACTERS:
        return 'tb'
    if name in BMR_CHARACTERS:
        return 'bmr'
    if name in SNV_CHARACTERS:
        return 'snv'
    return "carousel"

def get_icon_url(character_type: type, is_evil: bool) -> str:
    name = character_type.__name__.lower()
    # If is_evil is explicitly True, always use 'e' icon.
    # Otherwise, check the character type if it's naturally evil.
    is_naturally_evil = issubclass(character_type, (characters.Minion, characters.Demon))
    alignment = "e" if (is_evil or is_naturally_evil) else "g"
    return f'icons/{name}_{alignment}.webp'

def render_puzzle(puzzle_or_state: Puzzle | State) -> str:
    """
    Produces a standalone HTML visualization of a Puzzle or State object.
    When a State is passed, true character and alignment info is used.
    """
    if isinstance(puzzle_or_state, State):
        state = puzzle_or_state
        puzzle = state.puzzle
        is_state = True
    else:
        puzzle = puzzle_or_state
        state = None
        is_state = False

    n_players = len(puzzle.players)
    names = {i: p.name for i, p in enumerate(puzzle.players)}
    names = [p.name for p in puzzle.players]
    
    cx = 500; cy = 500
    token_radius = n_players * 32
    info_radius_x = token_radius + 90
    info_radius_y = token_radius + 137
    
    player_deaths = {}
    max_night_val = max(list(puzzle.night_deaths.keys()) + list(puzzle.day_events.keys()) + [0])
    
    for n in range(1, max_night_val + 1):
        if n in puzzle.night_deaths:
            deaths = puzzle.night_deaths[n]
            if isinstance(deaths, (int, events.Event)): deaths = [deaths]
            for death in deaths:
                pid = death.player if hasattr(death, 'player') else death
                if pid not in player_deaths:
                    player_deaths[pid] = {"text": f"Died N{n}", "type": "nature"}
        
        if n in puzzle.day_events:
            evs = puzzle.day_events[n]
            if not isinstance(evs, list): evs = [evs]
            for ev in evs:
                if isinstance(ev, events.Execution) and ev.died:
                    if ev.player not in player_deaths:
                        player_deaths[ev.player] = {"text": f"Executed D{n}", "type": "execution"}
                elif hasattr(ev, 'died') and ev.died and hasattr(ev, 'player'):
                    if ev.player not in player_deaths:
                        player_deaths[ev.player] = {"text": f"Died D{n}", "type": "nature"}

    # Bounds tracking
    min_x = cx; max_x = cx; min_y = cy; max_y = cy

    def update_bounds(x, y, w=0, h=0, tx=0, ty=0):
        nonlocal min_x, max_x, min_y, max_y
        # x, y are un-shifted positions. tx, ty are percentage translations as decimals (-0.5 etc)
        left = x + (tx * w)
        right = left + w
        top = y + (ty * h)
        bottom = top + h
        min_x = min(min_x, left)
        max_x = max(max_x, right)
        min_y = min(min_y, top)
        max_y = max(max_y, bottom)

    # 1. Events box
    event_html_items = []
    for n in range(1, max_night_val + 1):
        if n in puzzle.night_deaths:
            deaths = puzzle.night_deaths[n]
            if not isinstance(deaths, list): deaths = [deaths]
            for d in deaths:
                d_str = d.display(names) if hasattr(d, 'display') else f"{names[d]} dies"
                event_html_items.append(f"<div><strong class='event-label'>N{n}:</strong> {d_str}</div>")
        if n in puzzle.day_events:
            evs = puzzle.day_events[n]
            if not isinstance(evs, list): evs = [evs]
            for ev in evs:
                ev_str = ev.display(names).replace('\n', '<br>').replace('  ', '&nbsp;&nbsp;')
                event_html_items.append(f"<div><strong class='event-label'>D{n}:</strong> {ev_str}</div>")
    
    if event_html_items:
        h_est = len(event_html_items) * 19 + 40
        update_bounds(cx, cy, 250, h_est, -0.5, -0.5)

    # 2. Player info data
    players_data = []
    for i, player in enumerate(puzzle.players):
        angle_deg = (i * 360 / n_players) - 90
        angle_rad = math.radians(angle_deg)
        cos_a = math.cos(angle_rad)
        sin_a = math.sin(angle_rad)
        
        # Positions
        t_x = cx + token_radius * cos_a
        t_y = cy + token_radius * sin_a
        i_x = cx + info_radius_x * cos_a
        i_y = cy + info_radius_y * sin_a
        
        # Token bounds
        update_bounds(t_x, t_y, 130, 200, -0.5, -0.5) # Token + label roughly 200 high

        # Determine alignment and role for calculations
        if is_state:
            actual_char = type(state.players[i].character)
            is_evil = state.players[i].is_evil
        else:
            is_evil = player.is_evil or issubclass(player.claim, (characters.Minion, characters.Demon))

        # Info lines
        player_info_lines = []
        
        # 1. Personal Night Info
        for (night, char), item in puzzle._night_info[i].items():
            info_str = item.display(names).replace('\n', '<br>').replace('  ', '&nbsp;&nbsp;')
            is_lying = state.players[i].lies_about_info(state) if is_state else False
            player_info_lines.append({
                "night": night, "day": None, "char": char, 
                "html": f"<strong>N{night}:</strong> {info_str}",
                "is_lying": is_lying
            })
            
        # 2. Daily Info
        for (day, char), item in puzzle._day_info[i].items():
            info_str = item.display(names).replace('\n', '<br>').replace('  ', '&nbsp;&nbsp;')
            is_lying = state.players[i].lies_about_info(state) if is_state else False
            player_info_lines.append({
                "night": None, "day": day, "char": char,
                "html": f"<strong>D{day}:</strong> {info_str}",
                "is_lying": is_lying
            })
            
        # 3. External info from registry
        for (char, night), items in puzzle.external_info_registry.items():
            for item, pid in items:
                if pid == i:
                    info_str = item.display(names).replace('\n', '<br>').replace('  ', '&nbsp;&nbsp;')
                    is_lying = info.behaves_evil(state, i) if is_state else False
                    player_info_lines.append({
                        "night": night, "day": None, "char": char,
                        "html": f"<strong>N{night}:</strong> {info_str}",
                        "is_lying": is_lying
                    })
        
        # Sort lines by night/day
        player_info_lines.sort(key=lambda x: (x["night"] or 0, x["day"] or 0))
        
        # Format HTML with per-line classes
        formatted_info_html_items = []
        for line in player_info_lines:
            lying_line_class = ""
            if line["is_lying"]:
                lying_line_class = "lying-evil" if is_evil else "lying-good"
            formatted_info_html_items.append(f'<div class="info-line {lying_line_class}">{line["html"]}</div>')
        
        info_html = "".join(formatted_info_html_items)
        
        if info_html:
            tx_p = 0; info_text_align = "center"; accent_style = ""; info_max_width = 350
            if cos_a > 0.4: # Right
                tx_p = 0; info_text_align = "left"; info_max_width = 180
                accent_style = "border-left: 3px solid var(--viz-accent);"
            elif cos_a < -0.4: # Left
                tx_p = -1; info_text_align = "right"; info_max_width = 180
                accent_style = "border-right: 3px solid var(--viz-accent); border-left: none;"
            else: # Top/Bottom
                tx_p = -0.5; info_text_align = "center"; info_max_width = 350
                accent_style = "border-left: 3px solid var(--viz-accent); border-right: 3px solid var(--viz-accent);"

            h_est = len(player_info_lines) * 20 + 30
            update_bounds(i_x, i_y, info_max_width, h_est, tx_p, -0.5) # ty is -0.5 with -14px nudge, close enough
            
            players_data.append({
                "index": i, "player": player, "tx_p": tx_p, "t_x": t_x, "t_y": t_y, "i_x": i_x, "i_y": i_y,
                "info_html": info_html, "info_text_align": info_text_align, "info_max_width": info_max_width, "accent_style": accent_style,
                "is_evil": is_evil
            })
        else:
            players_data.append({
                "index": i, "player": player, "t_x": t_x, "t_y": t_y, "i_x": i_x, "i_y": i_y, "info_html": "",
                "is_evil": is_evil
            })

    # Final Bounds calculation with padding
    pad_x = 30
    pad_top = 60
    pad_bot = 10
    
    # Symmetric Horizontal Centering
    # Calculate furthest distance from center cx to any edge
    dist_x = max(cx - min_x, max_x - cx)
    actual_min_x = cx - dist_x - pad_x
    actual_max_x = cx + dist_x + pad_x
    
    # Vertical bounds (non-symmetric)
    actual_min_y = min_y - pad_top
    actual_max_y = max_y + pad_bot
    
    actual_width = actual_max_x - actual_min_x
    internal_width = max(1000, actual_width)
    internal_height = actual_max_y - actual_min_y
    
    # Center the content horizontally within internal_width if it's wider than the content
    shift_x = actual_min_x - (internal_width - actual_width) / 2
    shift_y = actual_min_y
    
    # Render loop
    player_html_list = []
    for d in players_data:
        i = d["index"]; player = d["player"]
        
        # Token CSS
        if is_state:
            actual_char = type(state.players[i].character)
            is_evil = state.players[i].is_evil
            role_name_display = actual_char.__name__
            icon_url = get_icon_url(actual_char, is_evil)
            
            is_lying = state.players[i].lies_about_info(state)

            color_class = "townsfolk"
            if issubclass(actual_char, characters.Demon): color_class = "demon"
            elif issubclass(actual_char, characters.Minion): color_class = "minion"
            elif issubclass(actual_char, characters.Outsider): color_class = "outsider"
        else:
            is_evil = player.is_evil or issubclass(player.claim, (characters.Minion, characters.Demon))
            role_name_display = player.claim.__name__
            icon_url = get_icon_url(player.claim, is_evil)
            
            is_lying = False

            color_class = "townsfolk"
            if issubclass(player.claim, characters.Demon): color_class = "demon"
            elif issubclass(player.claim, characters.Minion): color_class = "minion"
            elif issubclass(player.claim, characters.Outsider): color_class = "outsider"

        evil_class = "evil" if is_evil else ""
        # Handle lying-good class for player name
        if not is_evil and is_lying:
            evil_class += " lying-good"
        elif is_evil and is_lying:
            evil_class += " lying-evil"

        death_info = player_deaths.get(i)
        dead_class = "dead" if death_info else ""
        death_type_class = death_info["type"] if death_info else ""
        death_label = death_info["text"] if death_info else ""

        token_left = d["t_x"] - shift_x
        token_top = d["t_y"] - shift_y

        info_html = ""
        if d["info_html"]:
            info_left = d["i_x"] - shift_x
            info_top = d["i_y"] - shift_y
            tx = f"{d['tx_p'] * 100}%"
            info_html = f"""
            <div class="player-info-outer" style="left: {info_left}px; top: {info_top}px; transform: translate({tx}, calc(-50% - 14px)); text-align: {d['info_text_align']};">
                <div class="player-info-content" style="max-width: {d['info_max_width']}px; {d['accent_style']}">{d["info_html"]}</div>
            </div>
            """


        player_html_list.append(f"""
            <div class="player-token-container" style="left: {token_left}px; top: {token_top}px;">
                <div class="player-token {color_class} {dead_class} {death_type_class}" data-death="{death_label}">
                    <div class="token-icon-wrap">
                        <img src="{icon_url}" class="role-icon">
                    </div>
                    <div class="role-name">{role_name_display}</div>
                </div>
                <div class="player-name-label {evil_class}">{player.name}</div>
            </div>
            {info_html}
        """)

    # Events Box
    events_section = ""
    if event_html_items:
        e_left = cx - shift_x
        e_top = cy - shift_y
        events_section = f'<div class="events-box" style="left: {e_left}px; top: {e_top}px;">{"".join(event_html_items)}</div>'

    # Hidden Roles
    unique_hidden = []
    all_hidden = puzzle.demons + puzzle.minions + puzzle.hidden_good + puzzle.hidden_self
    for h in all_hidden:
        if h not in unique_hidden: unique_hidden.append(h)
            
    hidden_html_items = []
    for role in unique_hidden:
        h_is_evil = issubclass(role, (characters.Minion, characters.Demon))
        h_icon = get_icon_url(role, h_is_evil)
        hidden_html_items.append(f"""
            <div class="hidden-role-token">
                <div class="token-icon-wrap" style="width: 55px; height: 55px; border: 2px solid var(--accent); position: relative;">
                    <img src="{h_icon}" class="role-icon" style="width: 100%; height: 100%; object-fit: contain; transform: scale(1.3);">
                </div>
                <div class="hidden-role-name">{role.__name__}</div>
            </div>
        """)

    html = f"""
    <div class="puzzle-app-container" style="--puzzle-internal-width: {internal_width}px; --puzzle-internal-height: {internal_height + 110}px;">
        <div class="puzzle-scaler">
            <div class="puzzle-window" style="width: {internal_width}px; height: {internal_height}px;">
                <div style="width: {internal_width}px; height: {internal_height}px; position: relative;">
                    {events_section}
                    {"".join(player_html_list)}
                </div>
            </div>
            
            <div class="hidden-roles-container">
                <div class="hidden-roles-title">Potential hidden roles:</div>
                <div class="hidden-roles-list">
                    {"".join(hidden_html_items)}
                </div>
            </div>
        </div>
    </div>
    """
    return html

def make_standalone_page(puzzles: Puzzle | list[Puzzle]) ->str:
    if isinstance(puzzles, Puzzle):
        puzzles = [puzzles]
    return f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ClockChecker Puzzle Visualisation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {{
            --bg-dark: #1b2631;
            --accent: #1abc9c;
            --text-white: #ffffff;
            --border: #2e4053;
            --puzzle-target-width: 100%;
            --puzzle-internal-width: 1000px;
            --puzzle-internal-height: 1000px;
            --puzzle-scale: calc(var(--puzzle-target-width) / var(--puzzle-internal-width));
        }}
        body {{
            background-color: var(--bg-dark);
            color: var(--text-white);
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }}
        .puzzle-app-container {{
            width: var(--puzzle-target-width);
            height: calc(var(--puzzle-scale) * var(--puzzle-internal-height));
            overflow: hidden;
        }}
        .puzzle-scaler {{
            width: var(--puzzle-internal-width);
            transform: scale(var(--puzzle-scale));
            transform-origin: top left;
        }}
        .puzzle-window {{
            position: relative;
            width: 1000px;
            height: 900px;
            background: transparent;
            user-select: none;
        }}
        .player-token-container {{
            position: absolute;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }}
        .player-token {{
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background-color: #fffdf5;
            border: 3px solid #555;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            position: relative;
            overflow: visible;
        }}
        .token-icon-wrap {{
            width: 80%;
            height: 80%;
            border-radius: 50%;
            overflow: hidden;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fffdf5; /* Restored background */
        }}
        .role-icon {{
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scale(1.3);
            margin-top: -10%;
        }}
        .role-name {{
            font-size: 13px;
            font-weight: bold;
            color: #333;
            text-shadow: 0 0 2px white;
            text-align: center;
            position: absolute;
            bottom: 10%;
            z-index: 8;
            width: 100%;
        }}
        .player-name-label {{
            margin-top: 8px;
            font-size: 20px;
            font-weight: 500;
            color: var(--accent);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }}
        
        .player-info-outer {{
            position: absolute;
            z-index: 5;
            pointer-events: none;
        }}
        .player-info-content {{
            font-size: 14px;
            color: var(--text-white);
            line-height: 1.4;
            background: rgba(0, 0, 0, 0.45);
            padding: 8px;
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            width: fit-content;
        }}
        
        .player-token.townsfolk {{ border-color: #1a73e8; }}
        .player-token.outsider {{ border-color: #1a73e8; opacity: 0.95; }}
        .player-token.minion {{ border-color: #d93025; }}
        .player-token.demon {{ border-color: #a50e0e; box-shadow: 0 0 20px rgba(165, 14, 14, 0.6); }}
        
        .player-token.dead::before {{
            content: "";
            position: absolute;
            width: 90px;
            height: 140px;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            opacity: 0.7;
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 50% 85%, 0% 100%);
            border: 1px solid rgba(0,0,0,0.3);
        }}
        .player-token.dead.nature::before {{ background-color: #c62828; border-top: 2px solid #500; }}
        .player-token.dead.execution::before {{ background-color: #1565c0; border-top: 2px solid #003; }}
        
        .player-token.dead::after {{
             content: attr(data-death);
             position: absolute;
             z-index: 6;
             top: 5px;
             left: 0;
             right: 0;
             color: white;
             font-weight: bold;
             font-size: 14px;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
             text-align: center;
        }}
        
        .events-box {{
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 10px;
            width: fit-content;
            max-width: 250px;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.45);
            padding: 10px;
            z-index: 1;
            color: var(--text-white);
            backdrop-filter: blur(5px);
        }}
        .event-label {{
            color: var(--accent);
            opacity: 0.8;
        }}
        
        .hidden-roles-container {{
            border: 2px solid var(--border);
            padding: 10px 15px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 30px;
            background: rgba(46, 64, 83, 0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: fit-content;
            margin: 20px auto 0 auto;
        }}
        .hidden-roles-title {{
            font-size: 16px;
            color: var(--accent);
            font-weight: bold;
            white-space: nowrap;
            letter-spacing: 1px;
        }}
        .hidden-roles-list {{
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }}
        .hidden-role-token {{
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 70px;
            overflow: visible;
        }}
        .hidden-role-name {{
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
            text-align: center;
        }}
    </style>
</head>
<body>
{"".join(render_puzzle(p) for p in puzzles)}
</body>
</html>
"""

if __name__ == "__main__":
    import puzzles

    PREFIXES = ('puzzle_', '_puzzle_')
    puzzle_names = [
        full_name[len(prefix):]
        for full_name in dir(puzzles) for prefix in PREFIXES
        if full_name.startswith(prefix)
    ]
    parser = argparse.ArgumentParser()
    parser.add_argument('puzzle_name', choices=puzzle_names, nargs='?', default='1')
    args = parser.parse_args(sys.argv[1:])

    for prefix in PREFIXES:
        factory = getattr(puzzles, f'{prefix}{args.puzzle_name}', None)
        if factory is not None:
            puzzle_def = factory()
            html = make_standalone_page(puzzle_def.puzzle)
            filename = f"testvis.html"
            with open(filename, "w") as f:
                f.write(html)
            print(f"Generated {filename}")
        break
    else:
        raise ValueError(f"Puzzle {args.puzzle_name} not found")