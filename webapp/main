import traceback

from pyscript import window, document, display
from pyscript.ffi import create_proxy

from clockchecker import *
from render_puzzle import render_puzzle


global_env = {}
exec("from clockchecker import *\n", global_env)

apply_btn = document.getElementById("applyButton")


def _stream_solve_to_output(puzzle, solve_override):
    for p in puzzle if isinstance(puzzle, tuple) else [puzzle]:
        p.user_interrupt = check_for_user_interrupt

    try:
        world_count = 0
        world_gen = solve(puzzle) if solve_override is None else solve_override()
        for world in world_gen:
            world_count += 1
            window.GUI_worldFound(format_world(world))
            if window.stopRequested:
                raise InterruptedError()
        if world_count == 0:
            window.GUI_returnError('No Solutions Found\n')
    except InterruptedError:
        window.GUI_returnError('\n======= Solve Stopped By User =======\n')
    except Exception as e:
        err_msg = '\nError while solving:\n' + traceback.format_exc()
        window.GUI_returnError(err_msg)

def apply_button_handler(event):
    window.GUI_startProcessing()
    puzzle_str = window.codeMirrorEditor.getValue()
    try:
        exec(puzzle_str + (
            "\n_stream_solve_to_output("
            "puzzle, "
            #"puzzle if 'puzzle' in locals().keys() else None,"
            "solve_override if 'solve_override' in locals().keys() else None,"
            ")\n" 
        ), global_env.copy())
    except Exception as e:
        msg = traceback.format_exc()
        window.GUI_returnError('Error in input:\n' + msg)
    window.GUI_finishedProcessing()

def keydown_handler(event):
    if (
        event.ctrlKey
        and event.key == 'Enter'
        and apply_btn.style.display != 'none'
    ):
        apply_button_handler(event)


check_count = 0
def check_for_user_interrupt() -> bool:
    global check_count
    check_count += 1
    if check_count % 500 == 0:
        return window.stopRequested
    return False

def format_world(world: State) -> str:
    world = str(world) + '\n'
    world = world.replace('\033[0;1m', '<span>')
    world = world.replace('\033[31;1m', '<span style="color: #ef4444; font-weight: bold;">')
    world = world.replace('\033[34;1m', '<span style="color: #3b78ff; font-weight: bold;">')
    world = world.replace('\033[0m', '</span>')
    return world


def render_puzzle_api(puzzle_str):
    try:
        env = global_env.copy()
        exec(puzzle_str, env)
        if 'puzzle' not in env:
            return {"success": False, "error": "No 'puzzle' variable defined in input."}
        
        puzzle_obj = env['puzzle']
        if isinstance(puzzle_obj, tuple):
            puzzle_obj = puzzle_obj[0]
            
        html = render_puzzle(puzzle_obj)
        return {"success": True, "html": html}
    except Exception as e:
        return {"success": False, "error": traceback.format_exc()}

global_env['_stream_solve_to_output'] = _stream_solve_to_output

apply_proxy = create_proxy(apply_button_handler)
keydown_proxy = create_proxy(keydown_handler)
render_proxy = create_proxy(render_puzzle_api)

apply_btn.addEventListener("click", apply_proxy)
document.addEventListener("keydown", keydown_proxy)
window.render_puzzle_api = render_proxy

# Only display solving button once python worker is initialised
document.getElementById("pythonLoadingMessage").remove()
apply_btn.style.display = 'flex'

# Trigger initial render
window.update_render()
